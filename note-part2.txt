Expensify-app

update in 

package.json
"name": "expensify-app",

public\index.html title as
expensify-app

-----React Router 101-----

https://reactrouter.com/en/main

react-router-dom for webapp

yarn add react-router-dom@4.2.2

app.js
import { BrowserRouter, Route} from "react-router-dom"

BrowserRouter expect only one child element, use div to add more inside

For client side routing, we handle all 404 & serve index.html

in webpack.config.js in devserver
add this 
historyApiFallback: true

& restart dev-server

It will start showing both component as it satify any matching routes
use exact={true} prop in route

-----Setting up a 404-----

create a component for NotFound

Switch
Check if previous conditions match, if match it will stop there & display that only else it will continue if no match found. 

-----Link between Routes-----
No need for refresh page using client side routing

Link
<Link to="/">Go home</Link>

NavLink similar to Kunk but mainly for navigation

activeClassName="is-active"
when we are on that Link

NavLink also similar to route, we need to use exact.

-----Organizing our Routes-----
src\routers\AppRouter

-----Query strings & url Parameters-----
prop objects
history (redirects)
match -> params
location (current url)
-> search (query string like ?query=rent&sort=date)
-> hash (#contact-us scroll to element that have id of this)

dynamically access value
in AppRouter.js
<Route path="/edit/:id" component={EditExpensePage}/>

creates match -> params -> id

in index.html
<script src="/bundle.js"></script>

props are passed to component in these Routes mentioned.

-----Redux-----
Manage state as our application grow in size

Issues
Not one Parent 
they need to keep track of data

component closely bound with Parent
cannot be used elsewhere

Where do i store my app state in a complex React app?
How do I create components that are actually reusable?

Redux Store
a property with array values with items
get & store data
e.x.
{
	expenses: [{
		_id: 'abc',
		description: 'rent',
		amount: 109500
	}]
}
-----Setting up Redux-----
playground/redux-101.js

webpack.config.js
entry: './src/playground/redux-101.js',

website for help
redux.js.org

yarn add redux@3.7.2

import { createStore } from 'redux';

-----Actions-----
Actions - It is an object that gets sent to the store

convention
Action type is written in capital letter (underscore can be used)

-----Subscribing & Dynamic Actions-----

store.subscribe(() => {
});
Its gets called everytime the store changes 

return value we get is unsubcribe, if we call it then further we will not be notified for state changes

const unsubscribe = store.subscribe(() => {
    console.log(store.getState());
});

store.dispatch({
    type: 'INCREMENT',
    incrementBy: 5
});

unsubscribe();

-----ES6 Object destructing---

destructing.js

in webpack.config.js
entry: './src/playground/destructing.js',

object destructing
const { name, age } = person;

renaming
const { city, temp: temperature } = person.location;

set default value
const { name = 'Anonymous', age } = person;

renaming & set default value
const { name: firstName = 'Anonymous', age } = person;

-----ES6 Array destructing---

const address = ['1299 S Juniper Street', 'Philadelphia', 'Pennsylvania', '19147'];

const [, city, state = 'New York'] = address;

-----Refracting & Organizing---

Action generators - functions that return action objects

-----Reducers---
Reducers are functions that take the current state and an action as arguments, and return a new state result. In other words, (state, action) => newState.

1. Reducers are pure functions 
(output depends on the input, does not change variables outside the scope).
2. Never change state or action

combineReducers 

-----ES6 Spread operator in Reducers---
uuid for generating unique id
yarn add uuid@3.1.0

names.concat('Julie')
concat returns a new array, doesn't edit the old names array

[...names, 'Mike']
Also returns new array with the change.
...names = all of the existing items in the array

state.filter return new array with subset of values.
state.filter(({ id }) => id !== action.id);

-----Spreading objects---
Getting all the properties of the object

Spreding object syntax is not yet in mainstream, so we need to customize babel configuration.

babel object spread operator
plugin-transform-object-rest-spread

yarn add babel-plugin-transform-object-rest-spread@6.23.0
{
  "plugins": ["transform-object-rest-spread"]
}

const user = {
    name: 'Jen',
    age: 24
}

console.log({
    ...user,
    location: 'Philadelphia',
    age: 27
});

-----Filtering Redux Data---
timestamps (milliseconds)
January 1st 1970 (unix epoch) (midnight)
33400, 10, -203

case insensitive search
expense.description.toLowerCase().includes(text.toLowerCase())

-----Sorting Redux Data---
arr.sort(compareFunction)

-----Organizing Redux---
src\selectors
src\actions
src\selectors
src\reducers

src\actions\expenses.js
src\actions\filters.js

src\reducers\expenses.js
src\reducers\filters.js

src\selectors\expenses.js

src\store\configureStore.js

-----The Higher Order Component---

src\playground\hoc.js

Higher Order Component (HOC)
A component that renders another component

Advantages is 
Reuse code
Render hijacking
Prop manipulation
Abstract state

const withAdminWarning = (WrappedComponent) => {
    return (props) => (

    );
};

const AdminInfo = withAdminWarning(Info);

using function to create a HOC

<WrappedComponent {...props}/>
Using spread operator to get all properties of the HOC

-----Connect Store & Component with React-Redux---
search google for react-redux

yarn add react-redux@5.0.5

1. Provider component
To provide the store to all other components that make up our application.

2. connect api
Connect your component to redux store

const mapStateToProps = (state) => {
    return {
        expenses: state.expenses,
        filters: state.filters
    };
};

export default connect(mapStateToProps)(ExpenseList);
